# buffer overflow

In pwgen.c, line 264, program tries to copy the command line argument into variable 'args.filename', which is a char array with size 512, using function strcpy(). This is a buffer overflow vulnerability.

I try to use the buffer overflow vulnerability to overwrite the return address so that the program will begin execute the injection code. Once it execute the injection code, I will get the root privilege.

Details as follows. 

The injection code is the shellcode introduced in 'stack smashing.pdf'. And in sploit.c, the program first prepare a buffer array and pass it as an argument to execute program 'pwgen'. Nearly the first $\frac{1}{3}$ of this buffer array is 'NOP'. And the shell code follows the 'NOP' segment. And the last segment which follows the shell code is filled with the address of the array 'args.filename' . The address is obtained by using gdb. I found that the address of the buffer 'args.filename' is 0xffbfda36. And the return pointer is 0xffbfdc3c. We then calculate that the size of our buffer array (the argument we passed to pwgen) can be 600 so that it is long enough to overwrite the return address. Since each program is started with the same stack pointer, which is 0xffbfdd80. We can calculate that if we have an offset which is equal to 800, the address, sp - offset, can be in the 'NOP' segment, and thus this is the address we want to fill in the last part of the buffer array (the argument we passed to pwgen).

Fix: change strcpy(args.filename, optarg) to strncpy(args.filename, optarg); Then, the buffer can't overflow and the return address won't be overwritten.

\end{enumerate}

\subsubsection*{Sploit2}

\begin{enumerate}% Sub-questions styled as italic letters

\item vulnerability: Time-of-check to time-of-use. If user call $pwgen \; --seed$, then in the function $parse\_args()$, program first check if file $/tmp/pwgen\_random$ is valid by function $check\_perms()$ on line 266. And then using function $fill\_entropy()$ on line 272 to seed that file. Before user supplied the seed, the program just waits. At the point the program is waiting for seed, user could recreate the file $/tmp/pwgen\_random$ and link it to $/etc/shadow$. And then, user supply the input, which will overwrite  $/etc/shadow$. The user can su root without any password.

\item exploit: The exploit will be very simple, we first use $popen$ to make the process $pwgen$ running, and then remove the file $/tmp/pwgen\_random$, and recreate using the same name, since we don't have permission for previous file, and then link it to $/etc/shadow$. After that, we use $fprintf(process, "\backslash nroot:::::::")$ to supply empty root password input, which will overwrite the $/etc/shadow$. Lastly, su root without password.

\item fix: We need to avoid letting user know the file name we want to write. Thus, if we use $mkstemp()$ to make temp files, then the attacker won't know how to link that file to $/etc/shadow$.

\end{enumerate}

\subsubsection*{Sploit3}

\begin{enumerate}% Sub-questions styled as italic letters

\item vulnerability: There is a format string vulnerability at line 269. function $fprintf$ will print a format string using the buffer obtained at line 268.

\item exploit: To make the program execute line 268, we can first create a dictionary $/tmp/pwgen\_random$ before the program start. After the program starts to execute, at line 266, the program use function $check\_perms()$ to check if the file $/tmp/pwgen\_random$ is valid. Function $check\_perms()$ will return -1 since it can't use unlink to remove a dictionary, and result executing line 268. We will prepare a string and pass it as the first argument $argv[0]$. The program will copy $argv[0]$ to buffer at line 268, the buffer size is 1024 which is enough for us to do our attack. 

In our sploit.c, we will prepare $argv[0]$ as follows. At the beginning of $argv[0]$, we will put two addresses, one is the return address of fprintf, that is 0xffbfd52c; and the other one is 0xffbfd52e. And then, put string "\%54763x\%39\$hn\%10688x\%40\$hn" as follows. The numbers in this string is well calculated so that $fprintf$ will overwrite the content of  0xffbfd52c 's last two bytes (using 39\$hn), and the content of 0xffbfd52e 's last two bytes (using 40\$hn). After the segment of that well calculated string, we will give many NOP to argv[0], and after NOP, we have our shellcode. Therefore, When $fprintf$ tries to print the format string, it will modify the content in the return address of $fprintf$, and make it be the address of some part in NOP segment. The $fprintf$ will print out the format string and return, but it will return to execute NOP and fall into the shellcode. And we will get the root.

\item fix: Change $fprintf(stderr, buffer)$ to $fprintf(stderr, "\%s", buffer)$ 

\end{enumerate}

\subsubsection*{Sploit4}

\begin{enumerate}% Sub-questions styled as italic letters

\item vulnerability: Incomplete mediation. At line 66 and line 47, in function $get\_gid$ and $get\_uid$, respectively.

\item exploit: We see that both functions trust the environment variable 'HOME'. So, we can change this environment variable to root before the program runs using $putenv("HOME=root")$. Then, $get\_gid$ and $get\_uid$ will return 0, which is the gid and uid of root. As we supply the argument option '-w' to the program, the program will update the password of root using the generated password. It is easy for us to get this generated password. In sploit.c, we can write the output of the program to a file first, and read from it to get the password. Then, we can write an expect script to su root using this password.

\item fix: change $get\_gid()$ to $getgid()$ and change $get\_uid$ to $getuid()$.
